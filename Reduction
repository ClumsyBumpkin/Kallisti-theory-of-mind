from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

import numpy as np

# holds settings and learning results 

@dataclass
class PCAReducer:
    n_components: int  # dimensions for refuction any integer 
    center: bool = True

    mean_: Optional[np.ndarray] = None
    components_: Optional[np.ndarray] = None
    explained_variance_: Optional[np.ndarray] = None
    
# fit(x) learns PCA (principal component analysis)from the obtained data   
    
    def fit(self, X: np.ndarray) -> "PCAReducer":
        X = np.asarray(X, dtype=float)
        if X.ndim != 2:
            raise ValueError("X must be a 2D array with shape (n_samples, n_features).")

        if self.n_components <= 0:
            raise ValueError("n_components must be >= 1.")
        if self.n_components > X.shape[1]:
            raise ValueError("n_components cannot exceed n_features.")

        if self.center:
            self.mean_ = X.mean(axis=0)
            Xc = X - self.mean_
        else:
            self.mean_ = np.zeros(X.shape[1], dtype=float)
            Xc = X

        U, S, Vt = np.linalg.svd(Xc, full_matrices=False)
        self.components_ = Vt[: self.n_components]
        n_samples = Xc.shape[0]
        denom = max(n_samples - 1, 1)
        self.explained_variance_ = (S[: self.n_components] ** 2) / denom

        return self

# take new data and compress into PCA with the transform function 
    
    def transform(self, X: np.ndarray) -> np.ndarray:
        if self.components_ is None or self.mean_ is None:
            raise RuntimeError("Reducer is not fit yet. Call fit(X) first.")

        X = np.asarray(X, dtype=float)
        if X.ndim == 1:
            X = X.reshape(1, -1)
        if X.ndim != 2:
            raise ValueError("X must be 1D or 2D array.")

        if X.shape[1] != self.mean_.shape[0]:
            raise ValueError("X has different number of features than data used for fit().")

        Xc = X - self.mean_
        Z = Xc @ self.components_.T
        return Z

    def fit_transform(self, X: np.ndarray) -> np.ndarray:
        return self.fit(X).transform(X)
